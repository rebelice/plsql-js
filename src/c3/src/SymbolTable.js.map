{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../src/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Mike Lischke. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n\nimport { ISymbolTableOptions, SymbolConstructor } from \"./types\";\n\nimport { BaseSymbol } from \"./BaseSymbol\";\nimport { ParseTree } from \"antlr4ts/tree/ParseTree\";\nimport { IScopedSymbol, ScopedSymbol } from \"./ScopedSymbol\";\nimport { NamespaceSymbol } from \"./NamespaceSymbol\";\n\nexport interface ISymbolTable extends IScopedSymbol {\n    options: ISymbolTableOptions;\n\n    /**\n     * @returns instance information, mostly relevant for unit testing.\n     */\n    info: { dependencyCount: number, symbolCount: number; };\n\n    clear(): void;\n    addDependencies(...tables: SymbolTable[]): void;\n    removeDependency(table: SymbolTable): void;\n    addNewSymbolOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        parent: ScopedSymbol | undefined, ...args: Args): T;\n\n    /**\n     * Asynchronously adds a new namespace to the symbol table or the given parent. The path parameter specifies a\n     * single namespace name or a chain of namespaces (which can be e.g. \"outer.intermittent.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     *\n     * @param parent The parent to add the namespace to.\n     * @param path The namespace path.\n     * @param delimiter The delimiter used in the path.\n     *\n     * @returns The new symbol.\n     */\n    addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string,\n        delimiter?: string): Promise<NamespaceSymbol>;\n\n    /**\n     * Synchronously adds a new namespace to the symbol table or the given parent. The path parameter specifies a\n     * single namespace name or a chain of namespaces (which can be e.g. \"outer.intermittent.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     *\n     * @param parent The parent to add the namespace to.\n     * @param path The namespace path.\n     * @param delimiter The delimiter used in the path.\n     *\n     * @returns The new symbol.\n     */\n    addNewNamespaceFromPathSync(parent: ScopedSymbol | undefined, path: string,\n        delimiter?: string): NamespaceSymbol;\n\n    /**\n     * Asynchronously returns all symbols from this scope (and optionally those from dependencies) of a specific type.\n     *\n     * @param t The type of the symbols to return.\n     * @param localOnly If true do not search dependencies.\n     *\n     * @returns A promise which resolves when all symbols are collected.\n     */\n    getAllSymbols<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly: boolean): Promise<T[]>;\n\n    /**\n     * Synchronously returns all symbols from this scope (and optionally those from dependencies) of a specific type.\n     *\n     * @param t The type of the symbols to return.\n     * @param localOnly If true do not search dependencies.\n     *\n     * @returns A list with all symbols.\n     */\n    getAllSymbolsSync<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly: boolean): T[];\n\n    /**\n     * Asynchronously looks for a symbol which is connected with a given parse tree context.\n     *\n     * @param context The context to search for.\n     *\n     * @returns A promise resolving to the found symbol or undefined.\n     */\n    symbolWithContext(context: ParseTree): Promise<BaseSymbol | undefined>;\n\n    /**\n     * Synchronously looks for a symbol which is connected with a given parse tree context.\n     *\n     * @param context The context to search for.\n     *\n     * @returns The found symbol or undefined.\n     */\n    symbolWithContextSync(context: ParseTree): BaseSymbol | undefined;\n\n    /**\n     * Asynchronously resolves a name to a symbol.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly A flag indicating if only this symbol table should be used or also its dependencies.\n     *\n     * @returns A promise resolving to the found symbol or undefined.\n     */\n    resolve(name: string, localOnly: boolean): Promise<BaseSymbol | undefined>;\n\n    /**\n     * Synchronously resolves a name to a symbol.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly A flag indicating if only this symbol table should be used or also its dependencies.\n     *\n     * @returns The found symbol or undefined.\n     */\n    resolveSync(name: string, localOnly: boolean): BaseSymbol | undefined;\n}\n\n/** The main class managing all the symbols for a top level entity like a file, library or similar. */\nexport class SymbolTable extends ScopedSymbol implements ISymbolTable {\n    /**  Other symbol information available to this instance. */\n    protected dependencies: Set<SymbolTable> = new Set();\n\n    public constructor(name: string, public readonly options: ISymbolTableOptions) {\n        super(name);\n    }\n\n    public get info(): { dependencyCount: number, symbolCount: number; } {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length,\n        };\n    }\n\n    public override clear(): void {\n        super.clear();\n        this.dependencies.clear();\n    }\n\n    public addDependencies(...tables: SymbolTable[]): void {\n        tables.forEach((value) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    public removeDependency(table: SymbolTable): void {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    public addNewSymbolOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        parent: ScopedSymbol | undefined, ...args: Args): T {\n\n        const result = new t(...args);\n        if (!parent || parent === this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n\n        return result;\n    }\n\n    public async addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string,\n        delimiter = \".\"): Promise<NamespaceSymbol> {\n        const parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent === undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = await currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace === undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    public addNewNamespaceFromPathSync(parent: ScopedSymbol | undefined, path: string,\n        delimiter = \".\"): NamespaceSymbol {\n        const parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent === undefined) ? this : parent;\n\n        while (i < parts.length - 1) {\n            let namespace = currentParent.resolveSync(parts[i], true) as NamespaceSymbol;\n            if (namespace === undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    public override async getAllSymbols<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly = false): Promise<T[]> {\n        const result: T[] = await super.getAllSymbols(t, localOnly);\n\n        if (!localOnly) {\n            const dependencyResults = await Promise.all([...this.dependencies].map((dependency) => {\n                return (\n                    dependency.getAllSymbols(t, localOnly)\n                );\n            }));\n\n            dependencyResults.forEach((value) => {\n                result.push(...value);\n            });\n        }\n\n        return result;\n    }\n\n    public override getAllSymbolsSync<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly = false): T[] {\n        const result: T[] = super.getAllSymbolsSync(t, localOnly);\n\n        if (!localOnly) {\n            this.dependencies.forEach((dependency) => {\n                result.push(...dependency.getAllSymbolsSync(t, localOnly));\n            });\n        }\n\n        return result;\n    }\n\n    public async symbolWithContext(context: ParseTree): Promise<BaseSymbol | undefined> {\n        /**\n         * Local function to find a symbol recursively.\n         *\n         * @param symbol The symbol to search through.\n         *\n         * @returns The symbol with the given context, if found.\n         */\n        const findRecursive = (symbol: BaseSymbol): BaseSymbol | undefined => {\n            if (symbol.context === context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (const child of symbol.children) {\n                    const result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n\n            return undefined;\n        };\n\n        let symbols = await this.getAllSymbols(BaseSymbol);\n        for (const symbol of symbols) {\n            const result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (const dependency of this.dependencies) {\n            symbols = await dependency.getAllSymbols(BaseSymbol);\n            for (const symbol of symbols) {\n                const result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    public symbolWithContextSync(context: ParseTree): BaseSymbol | undefined {\n        /**\n         * Local function to find a symbol recursively.\n         *\n         * @param symbol The symbol to search through.\n         *\n         * @returns The symbol with the given context, if found.\n         */\n        const findRecursive = (symbol: BaseSymbol): BaseSymbol | undefined => {\n            if (symbol.context === context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (const child of symbol.children) {\n                    const result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n\n            return undefined;\n        };\n\n        let symbols = this.getAllSymbolsSync(BaseSymbol);\n        for (const symbol of symbols) {\n            const result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (const dependency of this.dependencies) {\n            symbols = dependency.getAllSymbolsSync(BaseSymbol);\n            for (const symbol of symbols) {\n                const result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    public override async resolve(name: string, localOnly = false): Promise<BaseSymbol | undefined> {\n        let result = await super.resolve(name, localOnly);\n        if (!result && !localOnly) {\n            for (const dependency of this.dependencies) {\n                result = await dependency.resolve(name, false);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    public override resolveSync(name: string, localOnly = false): BaseSymbol | undefined {\n        let result = super.resolveSync(name, localOnly);\n        if (!result && !localOnly) {\n            for (const dependency of this.dependencies) {\n                result = dependency.resolveSync(name, false);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"]}