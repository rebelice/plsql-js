{"version":3,"file":"CodeCompletionCore.js","sourceRoot":"","sources":["../../src/CodeCompletionCore.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Mike Lischke. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { Parser, Vocabulary, Token, TokenStream, ParserRuleContext } from \"antlr4ts\";\nimport {\n    ATN, ATNState, ATNStateType, Transition, PredicateTransition, RuleTransition, RuleStartState,\n    PrecedencePredicateTransition, TransitionType,\n} from \"antlr4ts/atn\";\nimport { IntervalSet } from \"antlr4ts/misc/IntervalSet\";\n\nimport { longestCommonPrefix } from \"./utils\";\n\nexport type TokenList = number[];\nexport type RuleList = number[];\n\nexport interface ICandidateRule {\n    startTokenIndex: number;\n    ruleList: RuleList;\n}\n\nexport interface IRuleWithStartToken {\n    startTokenIndex: number;\n    ruleIndex: number;\n}\n\nexport type RuleWithStartTokenList = IRuleWithStartToken[];\n\n/**\n * All the candidates which have been found. Tokens and rules are separated.\n * Token entries include a list of tokens that directly follow them (see also the \"following\" member in the\n * FollowSetWithPath class).\n * Rule entries include the index of the starting token within the evaluated rule, along with a call stack of rules\n * found during evaluation.\n */\nexport class CandidatesCollection {\n    public tokens: Map<number, TokenList> = new Map();\n    public rules: Map<number, ICandidateRule> = new Map();\n}\n\n/**\n * A record for a follow set along with the path at which this set was found.\n * If there is only a single symbol in the interval set then we also collect and store tokens which follow\n * this symbol directly in its rule (i.e. there is no intermediate rule transition). Only single label transitions\n * are considered. This is useful if you have a chain of tokens which can be suggested as a whole, because there is\n * a fixed sequence in the grammar.\n */\nclass FollowSetWithPath {\n    public intervals: IntervalSet;\n    public path: RuleList = [];\n    public following: TokenList = [];\n}\n\n/**\n * A list of follow sets (for a given state number) + all of them combined for quick hit tests + whether they are\n * exhaustive (false if subsequent yet-unprocessed rules could add further tokens to the follow set, true otherwise).\n * This data is static in nature (because the used ATN states are part of a static struct: the ATN).\n * Hence it can be shared between all C3 instances, however it depends on the actual parser class (type).\n */\nclass FollowSetsHolder {\n    public sets: FollowSetWithPath[];\n    public combined: IntervalSet;\n    public isExhaustive: boolean;\n}\n\ntype FollowSetsPerState = Map<number, FollowSetsHolder>;\n\n/** Token stream position info after a rule was processed. */\ntype RuleEndStatus = Set<number>;\n\ninterface IPipelineEntry {\n    state: ATNState;\n    tokenListIndex: number;\n}\n\n/** The main class for doing the collection process. */\nexport class CodeCompletionCore {\n    private static followSetsByATN = new Map<string, FollowSetsPerState>();\n\n    private static atnStateTypeMap: string[] = [\n        \"invalid\",\n        \"basic\",\n        \"rule start\",\n        \"block start\",\n        \"plus block start\",\n        \"star block start\",\n        \"token start\",\n        \"rule stop\",\n        \"block end\",\n        \"star loop back\",\n        \"star loop entry\",\n        \"plus loop back\",\n        \"loop end\",\n    ];\n\n    // Debugging options. Print human readable ATN state and other info.\n\n    /** Not dependent on showDebugOutput. Prints the collected rules + tokens to terminal. */\n    public showResult = false;\n\n    /** Enables printing ATN state info to terminal. */\n    public showDebugOutput = false;\n\n    /** Only relevant when showDebugOutput is true. Enables transition printing for a state. */\n    public debugOutputWithTransitions = false;\n\n    /** Also depends on showDebugOutput. Enables call stack printing for each rule recursion. */\n    public showRuleStack = false;\n\n    /**\n     * Tailoring of the result:\n     * Tokens which should not appear in the candidates set.\n     */\n    public ignoredTokens: Set<number>;\n\n    /**\n     * Rules which replace any candidate token they contain.\n     * This allows to return descriptive rules (e.g. className, instead of ID/identifier).\n     */\n    public preferredRules: Set<number>;\n\n    /**\n     * Specify if preferred rules should translated top-down (higher index rule returns first) or\n     * bottom-up (lower index rule returns first).\n     */\n    public translateRulesTopDown = false;\n\n    private parser: Parser;\n    private atn: ATN;\n    private vocabulary: Vocabulary;\n    private ruleNames: string[];\n    private tokens: Token[];\n    private precedenceStack: number[];\n\n    private tokenStartIndex = 0;\n    private statesProcessed = 0;\n\n    /**\n     * A mapping of rule index + token stream position to end token positions.\n     * A rule which has been visited before with the same input position will always produce the same output positions.\n     */\n    private shortcutMap: Map<number, Map<number, RuleEndStatus>> = new Map();\n\n    /** The collected candidates (rules and tokens). */\n    private candidates: CandidatesCollection = new CandidatesCollection();\n\n    public constructor(parser: Parser) {\n        this.parser = parser;\n        this.atn = parser.atn;\n        this.vocabulary = parser.vocabulary;\n        this.ruleNames = parser.ruleNames;\n        this.ignoredTokens = new Set();\n        this.preferredRules = new Set();\n    }\n\n    /**\n     * This is the main entry point. The caret token index specifies the token stream index for the token which\n     * currently covers the caret (or any other position you want to get code completion candidates for).\n     * Optionally you can pass in a parser rule context which limits the ATN walk to only that or called rules.\n     * This can significantly speed up the retrieval process but might miss some candidates (if they are outside of\n     * the given context).\n     *\n     * @param caretTokenIndex The index of the token at the caret position.\n     * @param context An option parser rule context to limit the search space.\n     * @returns The collection of completion candidates.\n     */\n    public collectCandidates(caretTokenIndex: number, context?: ParserRuleContext): CandidatesCollection {\n        this.shortcutMap.clear();\n        this.candidates.rules.clear();\n        this.candidates.tokens.clear();\n        this.statesProcessed = 0;\n        this.precedenceStack = [];\n\n        this.tokenStartIndex = context ? context.start.tokenIndex : 0;\n        const tokenStream: TokenStream = this.parser.inputStream;\n\n        this.tokens = [];\n        let offset = this.tokenStartIndex;\n        while (true) {\n            const token = tokenStream.get(offset++);\n            if (token.channel === Token.DEFAULT_CHANNEL) {\n                this.tokens.push(token);\n\n                if (token.tokenIndex >= caretTokenIndex || token.type === Token.EOF) {\n                    break;\n                }\n            }\n\n            // Do not check for the token index here, as we want to end with the first unhidden token on or after\n            // the caret.\n            if (token.type === Token.EOF) {\n                break;\n            }\n        }\n\n        const callStack: RuleWithStartTokenList = [];\n        const startRule = context ? context.ruleIndex : 0;\n        this.processRule(this.atn.ruleToStartState[startRule], 0, callStack, 0, 0);\n\n        if (this.showResult) {\n            console.log(`States processed: ${this.statesProcessed}`);\n            console.log(\"\\n\\nCollected rules:\\n\");\n            for (const rule of this.candidates.rules) {\n                let path = \"\";\n                for (const token of rule[1].ruleList) {\n                    path += this.ruleNames[token] + \" \";\n                }\n                console.log(this.ruleNames[rule[0]] + \", path: \", path);\n            }\n\n            const sortedTokens: Set<string> = new Set();\n            for (const token of this.candidates.tokens) {\n                let value = this.vocabulary.getDisplayName(token[0]);\n                for (const following of token[1]) {\n                    value += \" \" + this.vocabulary.getDisplayName(following);\n                }\n                sortedTokens.add(value);\n            }\n\n            console.log(\"\\n\\nCollected tokens:\\n\");\n            for (const symbol of sortedTokens) {\n                console.log(symbol);\n            }\n            console.log(\"\\n\\n\");\n        }\n\n        return this.candidates;\n    }\n\n    /**\n     * Checks if the predicate associated with the given transition evaluates to true.\n     *\n     * @param transition The transition to check.\n     * @returns the evaluation result of the predicate.\n     */\n    private checkPredicate(transition: PredicateTransition): boolean {\n        return transition.predicate.eval(this.parser, ParserRuleContext.emptyContext());\n    }\n\n    /**\n     * Walks the rule chain upwards or downwards (depending on translateRulesTopDown) to see if that matches any of the\n     * preferred rules. If found, that rule is added to the collection candidates and true is returned.\n     *\n     * @param ruleWithStartTokenList The list to convert.\n     * @returns true if any of the stack entries was converted.\n     */\n    private translateStackToRuleIndex(ruleWithStartTokenList: RuleWithStartTokenList): boolean {\n        if (this.preferredRules.size === 0) {\n            return false;\n        }\n\n        // Change the direction we iterate over the rule stack\n        if (this.translateRulesTopDown) {\n            // Loop over the rule stack from lowest to highest rule level. This will prioritize a lower preferred rule\n            // if it is a child of a higher one that is also a preferred rule.\n            for (let i = ruleWithStartTokenList.length - 1; i >= 0; i--) {\n                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {\n                    return true;\n                }\n            }\n        } else {\n            // Loop over the rule stack from highest to lowest rule level. This will prioritize a higher preferred rule\n            // if it contains a lower one that is also a preferred rule.\n            for (let i = 0; i < ruleWithStartTokenList.length; i++) {\n                if (this.translateToRuleIndex(i, ruleWithStartTokenList)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Given the index of a rule from a rule chain, check if that matches any of the preferred rules. If it matches,\n     * that rule is added to the collection candidates and true is returned.\n     *\n     * @param i The rule index.\n     * @param ruleWithStartTokenList The list to check.\n     * @returns true if the specified rule is in the list of preferred rules.\n     */\n    private translateToRuleIndex(i: number, ruleWithStartTokenList: RuleWithStartTokenList): boolean {\n        const { ruleIndex, startTokenIndex } = ruleWithStartTokenList[i];\n        if (this.preferredRules.has(ruleIndex)) {\n            // Add the rule to our candidates list along with the current rule path,\n            // but only if there isn't already an entry like that.\n            const path = ruleWithStartTokenList.slice(0, i).map(({ ruleIndex: candidate }) => { return candidate; });\n            let addNew = true;\n            for (const rule of this.candidates.rules) {\n                if (rule[0] !== ruleIndex || rule[1].ruleList.length !== path.length) {\n                    continue;\n                }\n\n                // Found an entry for this rule. Same path? If so don't add a new (duplicate) entry.\n                if (path.every((v, j) => { return v === rule[1].ruleList[j]; })) {\n                    addNew = false;\n                    break;\n                }\n            }\n\n            if (addNew) {\n                this.candidates.rules.set(ruleIndex, {\n                    startTokenIndex,\n                    ruleList: path,\n                });\n                if (this.showDebugOutput) {\n                    console.log(\"=====> collected: \", this.ruleNames[ruleIndex]);\n                }\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * This method follows the given transition and collects all symbols within the same rule that directly follow it\n     * without intermediate transitions to other rules and only if there is a single symbol for a transition.\n     *\n     * @param transition The transition from which to start.\n     * @returns A list of toke types.\n     */\n    private getFollowingTokens(transition: Transition): number[] {\n        const result: number[] = [];\n\n        const pipeline: ATNState[] = [transition.target];\n\n        while (pipeline.length > 0) {\n            const state = pipeline.pop();\n\n            if (state) {\n                state.getTransitions().forEach((outgoing) => {\n                    if (outgoing.serializationType === TransitionType.ATOM) {\n                        if (!outgoing.isEpsilon) {\n                            const list = outgoing.label!.toArray();\n                            if (list.length === 1 && !this.ignoredTokens.has(list[0])) {\n                                result.push(list[0]);\n                                pipeline.push(outgoing.target);\n                            }\n                        } else {\n                            pipeline.push(outgoing.target);\n                        }\n                    }\n                });\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Entry point for the recursive follow set collection function.\n     *\n     * @param start Start state.\n     * @param stop Stop state.\n     * @returns Follow sets.\n     */\n    private determineFollowSets(start: ATNState, stop: ATNState): FollowSetsHolder {\n        const sets: FollowSetWithPath[] = [];\n        const stateStack: ATNState[] = [];\n        const ruleStack: number[] = [];\n        const isExhaustive = this.collectFollowSets(start, stop, sets, stateStack, ruleStack);\n        // Sets are split by path to allow translating them to preferred rules. But for quick hit tests\n        // it is also useful to have a set with all symbols combined.\n        const combined = new IntervalSet();\n        for (const set of sets) {\n            combined.addAll(set.intervals);\n        }\n\n        return { sets, isExhaustive, combined };\n    }\n\n    /**\n     * Collects possible tokens which could be matched following the given ATN state. This is essentially the same\n     * algorithm as used in the LL1Analyzer class, but here we consider predicates also and use no parser rule context.\n     *\n     * @param s The state to continue from.\n     * @param stopState The state which ends the collection routine.\n     * @param followSets A pass through parameter to add found sets to.\n     * @param stateStack A stack to avoid endless recursions.\n     * @param ruleStack The current rule stack.\n     * @returns true if the follow sets is exhaustive, i.e. we terminated before the rule end was reached, so no\n     * subsequent rules could add tokens\n     */\n    private collectFollowSets(s: ATNState, stopState: ATNState, followSets: FollowSetWithPath[], stateStack: ATNState[],\n        ruleStack: number[]): boolean {\n\n        if (stateStack.find((x) => { return x === s; })) {\n            return true;\n        }\n        stateStack.push(s);\n\n        if (s === stopState || s.stateType === ATNStateType.RULE_STOP) {\n            stateStack.pop();\n\n            return false;\n        }\n\n        let isExhaustive = true;\n        for (const transition of s.getTransitions()) {\n            if (transition.serializationType === TransitionType.RULE) {\n                const ruleTransition: RuleTransition = transition as RuleTransition;\n                if (ruleStack.indexOf(ruleTransition.target.ruleIndex) !== -1) {\n                    continue;\n                }\n\n                ruleStack.push(ruleTransition.target.ruleIndex);\n                const ruleFollowSetsIsExhaustive = this.collectFollowSets(\n                    transition.target, stopState, followSets, stateStack, ruleStack);\n                ruleStack.pop();\n\n                // If the subrule had an epsilon transition to the rule end, the tokens added to\n                // the follow set are non-exhaustive and we should continue processing subsequent transitions post-rule\n                if (!ruleFollowSetsIsExhaustive) {\n                    const nextStateFollowSetsIsExhaustive = this.collectFollowSets(\n                        ruleTransition.followState, stopState, followSets, stateStack, ruleStack);\n                    isExhaustive &&= nextStateFollowSetsIsExhaustive;\n                }\n\n            } else if (transition.serializationType === TransitionType.PREDICATE) {\n                if (this.checkPredicate(transition as PredicateTransition)) {\n                    const nextStateFollowSetsIsExhaustive = this.collectFollowSets(\n                        transition.target, stopState, followSets, stateStack, ruleStack);\n                    isExhaustive &&= nextStateFollowSetsIsExhaustive;\n                }\n            } else if (transition.isEpsilon) {\n                const nextStateFollowSetsIsExhaustive = this.collectFollowSets(\n                    transition.target, stopState, followSets, stateStack, ruleStack);\n                isExhaustive &&= nextStateFollowSetsIsExhaustive;\n            } else if (transition.serializationType === TransitionType.WILDCARD) {\n                const set = new FollowSetWithPath();\n                set.intervals = IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);\n                set.path = ruleStack.slice();\n                followSets.push(set);\n            } else {\n                let label = transition.label;\n                if (label && label.size > 0) {\n                    if (transition.serializationType === TransitionType.NOT_SET) {\n                        label = label.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                    }\n                    const set = new FollowSetWithPath();\n                    set.intervals = label;\n                    set.path = ruleStack.slice();\n                    set.following = this.getFollowingTokens(transition);\n                    followSets.push(set);\n                }\n            }\n        }\n        stateStack.pop();\n\n        return isExhaustive;\n    }\n\n    /**\n     * Walks the ATN for a single rule only. It returns the token stream position for each path that could be matched\n     * in this rule.\n     * The result can be empty in case we hit only non-epsilon transitions that didn't match the current input or if we\n     * hit the caret position.\n     *\n     * @param startState The start state.\n     * @param tokenListIndex The token index we are currently at.\n     * @param callStack The stack that indicates where in the ATN we are currently.\n     * @param precedence The current precedence level.\n     * @param indentation A value to determine the current indentation when doing debug prints.\n     * @returns the set of token stream indexes (which depend on the ways that had to be taken).\n     */\n    private processRule(startState: RuleStartState, tokenListIndex: number, callStack: RuleWithStartTokenList,\n        precedence: number, indentation: number): RuleEndStatus {\n\n        // Start with rule specific handling before going into the ATN walk.\n\n        // Check first if we've taken this path with the same input before.\n        let positionMap = this.shortcutMap.get(startState.ruleIndex);\n        if (!positionMap) {\n            positionMap = new Map();\n            this.shortcutMap.set(startState.ruleIndex, positionMap);\n        } else {\n            if (positionMap.has(tokenListIndex)) {\n                if (this.showDebugOutput) {\n                    console.log(\"=====> shortcut\");\n                }\n\n                return positionMap.get(tokenListIndex)!;\n            }\n        }\n\n        const result: RuleEndStatus = new Set<number>();\n\n        // For rule start states we determine and cache the follow set, which gives us 3 advantages:\n        // 1) We can quickly check if a symbol would be matched when we follow that rule. We can so check in advance\n        //    and can save us all the intermediate steps if there is no match.\n        // 2) We'll have all symbols that are collectable already together when we are at the caret on rule enter.\n        // 3) We get this lookup for free with any 2nd or further visit of the same rule, which often happens\n        //    in non trivial grammars, especially with (recursive) expressions and of course when invoking code\n        //    completion multiple times.\n        let setsPerState = CodeCompletionCore.followSetsByATN.get(this.parser.constructor.name);\n        if (!setsPerState) {\n            setsPerState = new Map();\n            CodeCompletionCore.followSetsByATN.set(this.parser.constructor.name, setsPerState);\n        }\n\n        let followSets = setsPerState.get(startState.stateNumber);\n        if (!followSets) {\n            const stop = this.atn.ruleToStopState[startState.ruleIndex];\n            followSets = this.determineFollowSets(startState, stop);\n            setsPerState.set(startState.stateNumber, followSets);\n        }\n\n        // Get the token index where our rule starts from our (possibly filtered) token list\n        const startTokenIndex = this.tokens[tokenListIndex].tokenIndex;\n\n        callStack.push({\n            startTokenIndex,\n            ruleIndex: startState.ruleIndex,\n        });\n\n        if (tokenListIndex >= this.tokens.length - 1) { // At caret?\n            if (this.preferredRules.has(startState.ruleIndex)) {\n                // No need to go deeper when collecting entries and we reach a rule that we want to collect anyway.\n                this.translateStackToRuleIndex(callStack);\n            } else {\n                // Convert all follow sets to either single symbols or their associated preferred rule and add\n                // the result to our candidates list.\n                for (const set of followSets.sets) {\n                    const fullPath = callStack.slice();\n\n                    // Rules derived from our followSet will always start at the same token as our current rule.\n                    const followSetPath = set.path.map((path) => {\n                        return {\n                            startTokenIndex,\n                            ruleIndex: path,\n                        };\n                    });\n\n                    fullPath.push(...followSetPath);\n                    if (!this.translateStackToRuleIndex(fullPath)) {\n                        for (const symbol of set.intervals.toArray()) {\n                            if (!this.ignoredTokens.has(symbol)) {\n                                if (this.showDebugOutput) {\n                                    console.log(\"=====> collected: \", this.vocabulary.getDisplayName(symbol));\n                                }\n                                if (!this.candidates.tokens.has(symbol)) {\n                                    // Following is empty if there is more than one entry in the set.\n                                    this.candidates.tokens.set(symbol, set.following);\n                                } else {\n                                    // More than one following list for the same symbol.\n                                    if (this.candidates.tokens.get(symbol) !== set.following) {\n                                        this.candidates.tokens.set(symbol, []);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (!followSets.isExhaustive) {\n                // If we're at the caret but the follow sets is non-exhaustive (empty or all tokens are optional),\n                // we should continue to collect tokens following this rule\n                result.add(tokenListIndex);\n            }\n\n            callStack.pop();\n\n            return result;\n\n        } else {\n            // Process the rule if we either could pass it without consuming anything (epsilon transition)\n            // or if the current input symbol will be matched somewhere after this entry point.\n            // Otherwise stop here.\n            const currentSymbol = this.tokens[tokenListIndex].type;\n            if (followSets.isExhaustive && !followSets.combined.contains(currentSymbol)) {\n                callStack.pop();\n\n                return result;\n            }\n        }\n\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.push(precedence);\n        }\n\n        // The current state execution pipeline contains all yet-to-be-processed ATN states in this rule.\n        // For each such state we store the token index + a list of rules that lead to it.\n        const statePipeline: IPipelineEntry[] = [];\n        let currentEntry;\n\n        // Bootstrap the pipeline.\n        statePipeline.push({ state: startState, tokenListIndex });\n\n        while (statePipeline.length > 0) {\n            currentEntry = statePipeline.pop()!;\n            ++this.statesProcessed;\n\n            const currentSymbol = this.tokens[currentEntry.tokenListIndex].type;\n\n            const atCaret = currentEntry.tokenListIndex >= this.tokens.length - 1;\n            if (this.showDebugOutput) {\n                this.printDescription(indentation, currentEntry.state, this.generateBaseDescription(currentEntry.state),\n                    currentEntry.tokenListIndex);\n                if (this.showRuleStack) {\n                    this.printRuleState(callStack);\n                }\n            }\n\n            if (currentEntry.state.stateType === ATNStateType.RULE_STOP) {\n                // Record the token index we are at, to report it to the caller.\n                result.add(currentEntry.tokenListIndex);\n                continue;\n            }\n\n            const transitions = currentEntry.state.getTransitions();\n\n            // We simulate here the same precedence handling as the parser does, which uses hard coded values.\n            // For rules that are not left recursive this value is ignored (since there is no precedence transition).\n            for (const transition of transitions) {\n                switch (transition.serializationType) {\n                    case TransitionType.RULE: {\n                        const ruleTransition = transition as RuleTransition;\n                        const endStatus = this.processRule(transition.target as RuleStartState,\n                            currentEntry.tokenListIndex, callStack, ruleTransition.precedence, indentation + 1);\n                        for (const position of endStatus) {\n                            statePipeline.push({\n                                state: (<RuleTransition>transition).followState,\n                                tokenListIndex: position,\n                            });\n                        }\n                        break;\n                    }\n\n                    case TransitionType.PREDICATE: {\n                        if (this.checkPredicate(transition as PredicateTransition)) {\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex,\n                            });\n                        }\n                        break;\n                    }\n\n                    case TransitionType.PRECEDENCE: {\n                        const predTransition = transition as PrecedencePredicateTransition;\n                        if (predTransition.precedence >= this.precedenceStack[this.precedenceStack.length - 1]) {\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex,\n                            });\n                        }\n\n                        break;\n                    }\n\n                    case TransitionType.WILDCARD: {\n                        if (atCaret) {\n                            if (!this.translateStackToRuleIndex(callStack)) {\n                                for (const token of IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)\n                                    .toArray()) {\n                                    if (!this.ignoredTokens.has(token)) {\n                                        this.candidates.tokens.set(token, []);\n                                    }\n                                }\n                            }\n                        } else {\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex + 1,\n                            });\n                        }\n                        break;\n                    }\n\n                    default: {\n                        if (transition.isEpsilon) {\n                            // Jump over simple states with a single outgoing epsilon transition.\n                            statePipeline.push({\n                                state: transition.target,\n                                tokenListIndex: currentEntry.tokenListIndex,\n                            });\n                            continue;\n                        }\n\n                        let set = transition.label;\n                        if (set && set.size > 0) {\n                            if (transition.serializationType === TransitionType.NOT_SET) {\n                                set = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                            }\n                            if (atCaret) {\n                                if (!this.translateStackToRuleIndex(callStack)) {\n                                    const list = set.toArray();\n                                    const hasTokenSequence = list.length === 1;\n                                    for (const symbol of list) {\n                                        if (!this.ignoredTokens.has(symbol)) {\n                                            if (this.showDebugOutput) {\n                                                console.log(\"=====> collected: \",\n                                                    this.vocabulary.getDisplayName(symbol));\n                                            }\n\n                                            const followingTokens = hasTokenSequence\n                                                ? this.getFollowingTokens(transition)\n                                                : [];\n                                            if (!this.candidates.tokens.has(symbol)) {\n                                                this.candidates.tokens.set(symbol, followingTokens);\n                                            } else {\n                                                this.candidates.tokens.set(\n                                                    symbol,\n                                                    longestCommonPrefix(followingTokens,\n                                                        this.candidates.tokens.get(symbol)));\n                                            }\n                                        }\n                                    }\n                                }\n                            } else {\n                                if (set.contains(currentSymbol)) {\n                                    if (this.showDebugOutput) {\n                                        console.log(\"=====> consumed: \", this.vocabulary.getDisplayName(currentSymbol));\n                                    }\n                                    statePipeline.push({\n                                        state: transition.target,\n                                        tokenListIndex: currentEntry.tokenListIndex + 1,\n                                    });\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        callStack.pop();\n        if (startState.isPrecedenceRule) {\n            this.precedenceStack.pop();\n        }\n\n        // Cache the result, for later lookup to avoid duplicate walks.\n        positionMap.set(tokenListIndex, result);\n\n        return result;\n    }\n\n    private generateBaseDescription(state: ATNState): string {\n        const stateValue = state.stateNumber === ATNState.INVALID_STATE_NUMBER ? \"Invalid\" : state.stateNumber;\n\n        return `[${stateValue} ${CodeCompletionCore.atnStateTypeMap[state.stateType]}] in ` +\n            `${this.ruleNames[state.ruleIndex]}`;\n    }\n\n    private printDescription(indentation: number, state: ATNState, baseDescription: string, tokenIndex: number) {\n\n        const indent = \"  \".repeat(indentation);\n        let output = indent;\n\n        let transitionDescription = \"\";\n        if (this.debugOutputWithTransitions) {\n            for (const transition of state.getTransitions()) {\n                let labels = \"\";\n                const symbols: number[] = transition.label ? transition.label.toArray() : [];\n                if (symbols.length > 2) {\n                    // Only print start and end symbols to avoid large lists in debug output.\n                    labels = this.vocabulary.getDisplayName(symbols[0]) + \" .. \" +\n                        this.vocabulary.getDisplayName(symbols[symbols.length - 1]);\n                } else {\n                    for (const symbol of symbols) {\n                        if (labels.length > 0) {\n                            labels += \", \";\n                        }\n                        labels += this.vocabulary.getDisplayName(symbol);\n                    }\n                }\n                if (labels.length === 0) {\n                    labels = \"ε\";\n                }\n                transitionDescription += `\\n${indent}\\t(${labels}) [${transition.target.stateNumber} ` +\n                    `${CodeCompletionCore.atnStateTypeMap[transition.target.stateType]}] in ` +\n                    `${this.ruleNames[transition.target.ruleIndex]}`;\n            }\n        }\n\n        if (tokenIndex >= this.tokens.length - 1) {\n            output += `<<${this.tokenStartIndex + tokenIndex}>> `;\n        } else {\n            output += `<${this.tokenStartIndex + tokenIndex}> `;\n        }\n        console.log(output + \"Current state: \" + baseDescription + transitionDescription);\n    }\n\n    private printRuleState(stack: RuleWithStartTokenList) {\n        if (stack.length === 0) {\n            console.log(\"<empty stack>\");\n\n            return;\n        }\n\n        for (const rule of stack) {\n            console.log(this.ruleNames[rule.ruleIndex]);\n        }\n    }\n\n}\n"]}