{"version":3,"file":"ClassSymbol.js","sourceRoot":"","sources":["../../src/ClassSymbol.ts"],"names":[],"mappings":";AAAA;;;GAGG;;;AAEH,mCAAyD;AAEzD,+CAA4C;AAE5C,iDAA8C;AAC9C,iDAA8C;AAE9C,2BAA2B;AAC3B,MAAa,WAAY,SAAQ,2BAAY;IAClC,QAAQ,GAAG,KAAK,CAAC;IACjB,SAAS,GAAG,qBAAa,CAAC,UAAU,CAAC;IAE5C,6FAA6F;IAC7F,gDAAgD;IAChC,OAAO,CAAgB;IAEvC,2EAA2E;IAC3E,gDAAgD;IAChC,UAAU,CAAuC;IAEjE,YAAmB,IAAY,EAAE,GAAkB,EAAE,IAA0C;QAC3F,KAAK,CAAC,IAAI,CAAC,CAAC;QACZ,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;QACnB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;IAC3B,CAAC;IAED,IAAW,SAAS,KAAc,OAAO,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC;IACxD,IAAW,IAAI,KAAe,OAAO,gBAAQ,CAAC,KAAK,CAAC,CAAC,CAAC;IAEtD;;;;OAIG;IACI,UAAU,CAAC,gBAAgB,GAAG,KAAK;QACtC,OAAO,IAAI,CAAC,gBAAgB,CAAC,2BAAY,CAAC,CAAC;IAC/C,CAAC;IAED;;;;OAIG;IACI,SAAS,CAAC,gBAAgB,GAAG,KAAK;QACrC,OAAO,IAAI,CAAC,gBAAgB,CAAC,yBAAW,CAAC,CAAC;IAC9C,CAAC;CACJ;AAtCD,kCAsCC","sourcesContent":["/*\n * Copyright (c) Mike Lischke. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n\nimport { IType, ReferenceKind, TypeKind } from \"./types\";\n\nimport { FieldSymbol } from \"./FieldSymbol\";\nimport { InterfaceSymbol } from \"./InterfaceSymbol\";\nimport { MethodSymbol } from \"./MethodSymbol\";\nimport { ScopedSymbol } from \"./ScopedSymbol\";\n\n/** Classes and structs. */\nexport class ClassSymbol extends ScopedSymbol implements IType {\n    public isStruct = false;\n    public reference = ReferenceKind.Irrelevant;\n\n    /** Usually only one member, unless the language supports multiple inheritance (like C++). */\n    // eslint-disable-next-line no-use-before-define\n    public readonly extends: ClassSymbol[];\n\n    /** Typescript allows a class to implement a class, not only interfaces. */\n    // eslint-disable-next-line no-use-before-define\n    public readonly implements: Array<ClassSymbol | InterfaceSymbol>;\n\n    public constructor(name: string, ext: ClassSymbol[], impl: Array<ClassSymbol | InterfaceSymbol>) {\n        super(name);\n        this.extends = ext;\n        this.implements = impl;\n    }\n\n    public get baseTypes(): IType[] { return this.extends; }\n    public get kind(): TypeKind { return TypeKind.Class; }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): Promise<MethodSymbol[]> {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns all fields.\n     */\n    public getFields(includeInherited = false): Promise<FieldSymbol[]> {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n}\n"]}