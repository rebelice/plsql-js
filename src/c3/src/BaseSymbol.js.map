{"version":3,"file":"BaseSymbol.js","sourceRoot":"","sources":["../../src/BaseSymbol.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Mike Lischke. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n\nimport { ParseTree } from \"antlr4ts/tree/ParseTree\";\n\nimport { MemberVisibility, Modifier, SymbolConstructor } from \"./types\";\n\nimport { type IScopedSymbol } from \"./ScopedSymbol\";\nimport { type ISymbolTable } from \"./SymbolTable\";\n\n/**\n * The root of the symbol table class hierarchy: a symbol can be any manageable entity (like a block), not only\n * things like variables or classes.\n * We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n * symbols can so provide additional APIs for simpler access to their sub elements, if needed.\n */\nexport class BaseSymbol {\n    /** The name of the symbol or empty if anonymous. */\n    public name;\n\n    /** Reference to the parse tree which contains this symbol. */\n    public context?: ParseTree;\n\n    public readonly modifiers = new Set<Modifier>();\n    public visibility = MemberVisibility.Unknown;\n\n    #parent?: IScopedSymbol;\n\n    public constructor(name = \"\") {\n        this.name = name;\n    }\n\n    public get parent(): IScopedSymbol | undefined {\n        return this.#parent;\n    }\n\n    public get firstSibling(): BaseSymbol | undefined {\n        if (!this.#parent) {\n            return undefined;\n        }\n\n        return this.#parent?.firstChild;\n    }\n\n    /**\n     * @returns the symbol before this symbol in its scope.\n     */\n    public get previousSibling(): BaseSymbol | undefined {\n        if (!this.#parent) {\n            return undefined;\n        }\n\n        if (!this.#parent) {\n            return this;\n        }\n\n        return this.#parent.previousSiblingOf(this);\n    }\n\n    /**\n     * @returns the symbol following this symbol in its scope.\n     */\n    public get nextSibling(): BaseSymbol | undefined {\n        return this.#parent?.nextSiblingOf(this);\n    }\n\n    public get lastSibling(): BaseSymbol | undefined {\n        return this.#parent?.lastChild;\n    }\n\n    /**\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public get next(): BaseSymbol | undefined {\n        return this.#parent?.nextOf(this);\n    }\n\n    /**\n     * @returns the outermost entity (below the symbol table) that holds us.\n     */\n    public get root(): BaseSymbol | undefined {\n        let run = this.#parent;\n        while (run) {\n            if (!run.parent || this.isSymbolTable(run.parent)) {\n                return run;\n            }\n            run = run.parent;\n        }\n\n        return run;\n    }\n\n    /**\n     * @returns the symbol table we belong too or undefined if we are not yet assigned.\n     */\n    public get symbolTable(): ISymbolTable | undefined {\n        if (this.isSymbolTable(this)) {\n            return this;\n        }\n\n        let run = this.#parent;\n        while (run) {\n            if (this.isSymbolTable(run)) {\n                return run;\n            }\n            run = run.parent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @returns the list of symbols from this one up to root.\n     */\n    public get symbolPath(): BaseSymbol[] {\n        const result: BaseSymbol[] = [];\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let run: BaseSymbol = this;\n        while (run) {\n            result.push(run);\n            if (!run.parent) {\n                break;\n            }\n            run = run.parent;\n        }\n\n        return result;\n    }\n\n    /**\n     * This is rather an internal method and should rarely be used by external code.\n     *\n     * @param parent The new parent to use.\n     */\n    public setParent(parent?: IScopedSymbol): void {\n        this.#parent = parent;\n    }\n\n    /**\n     * Remove this symbol from its parent scope.\n     */\n    public removeFromParent(): void {\n        this.#parent?.removeSymbol(this);\n        this.#parent = undefined;\n    }\n\n    /**\n     * Asynchronously looks up a symbol with a given name, in a bottom-up manner.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public async resolve(name: string, localOnly = false): Promise<BaseSymbol | undefined> {\n        return this.#parent?.resolve(name, localOnly);\n    }\n\n    /**\n     * Synchronously looks up a symbol with a given name, in a bottom-up manner.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public resolveSync(name: string, localOnly = false): BaseSymbol | undefined {\n        return this.#parent?.resolveSync(name, localOnly);\n    }\n\n    /**\n     * @param t The type of objects to return.\n     *\n     * @returns the next enclosing parent of the given type.\n     */\n    public getParentOfType<T extends BaseSymbol>(t: SymbolConstructor<T, unknown[]>): T | undefined {\n        let run = this.#parent;\n        while (run) {\n            if (run instanceof t) {\n                return run;\n            }\n            run = run.parent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Creates a qualified identifier from this symbol and its parent.\n     * If `full` is true then all parents are traversed in addition to this instance.\n     *\n     * @param separator The string to be used between the parts.\n     * @param full A flag indicating if the full path is to be returned.\n     * @param includeAnonymous Use a special string for empty scope names.\n     *\n     * @returns the constructed qualified identifier.\n     */\n    public qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length === 0) {\n            return \"\";\n        }\n\n        let result: string = this.name.length === 0 ? \"<anonymous>\" : this.name;\n        let run = this.#parent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length === 0 ? \"<anonymous>\" : run.name) + separator + result;\n            }\n\n            if (!full || !run.parent) {\n                break;\n            }\n            run = run.parent;\n        }\n\n        return result;\n    }\n\n    /**\n     * Type guard to check for ISymbolTable.\n     *\n     * @param candidate The object to check.\n     *\n     * @returns true if the object is a symbol table.\n     */\n    private isSymbolTable(candidate: unknown): candidate is ISymbolTable {\n        return (candidate as ISymbolTable).info !== undefined;\n    }\n}\n"]}