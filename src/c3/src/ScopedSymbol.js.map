{"version":3,"file":"ScopedSymbol.js","sourceRoot":"","sources":["../../src/ScopedSymbol.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright (c) Mike Lischke. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n */\n\nimport { SymbolConstructor } from \"./types\";\n\nimport { BaseSymbol } from \"./BaseSymbol\";\nimport { DuplicateSymbolError } from \"./DuplicateSymbolError\";\nimport { INamespaceSymbol } from \"./NamespaceSymbol\";\n\n/** Defines the  */\nexport interface IScopedSymbol extends BaseSymbol {\n    /**\n     * @returns A promise resolving to all direct child symbols with a scope (e.g. classes in a module).\n     */\n    directScopes: Promise<ScopedSymbol[]>;\n\n    children: BaseSymbol[];\n    firstChild: BaseSymbol | undefined;\n    lastChild: BaseSymbol | undefined;\n\n    clear(): void;\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     *\n     * @param symbol The symbol to add as a child.\n     */\n    addSymbol(symbol: BaseSymbol): void;\n\n    /** Removes the given symbol from this scope, if it exists. */\n    removeSymbol(symbol: BaseSymbol): void;\n\n    /**\n     * Asynchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to all (nested) children of the given type.\n     */\n    getNestedSymbolsOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>): Promise<T[]>;\n\n    /**\n     * Synchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A list of all (nested) children of the given type.\n     */\n    getNestedSymbolsOfTypeSync<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>): T[];\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A promise resolving to symbols from this and all nested scopes in the order they were defined.\n     */\n    getAllNestedSymbols(name?: string): Promise<BaseSymbol[]>;\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A list of all symbols from this and all nested scopes in the order they were defined.\n     */\n    getAllNestedSymbolsSync(name?: string): BaseSymbol[];\n\n    /**\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to direct children of a given type.\n     */\n    getSymbolsOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>): Promise<T[]>;\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    getAllSymbols<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly?: boolean): Promise<T[]>;\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A list with all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    getAllSymbolsSync<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly?: boolean): T[];\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    resolve(name: string, localOnly?: boolean): Promise<BaseSymbol | undefined>;\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    resolveSync(name: string, localOnly?: boolean): BaseSymbol | undefined;\n\n    /**\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     *\n     * @returns the symbol located at the given path through the symbol hierarchy.\n     */\n    symbolFromPath(path: string, separator: string): BaseSymbol | undefined;\n\n    /**\n     * @param child The child to search for.\n     *\n     * @returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    indexOfChild(child: BaseSymbol): number;\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol after the given child symbol, if one exists.\n     */\n    nextSiblingOf(child: BaseSymbol): BaseSymbol | undefined;\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol before the given child symbol, if one exists.\n     */\n    previousSiblingOf(child: BaseSymbol): BaseSymbol | undefined;\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    nextOf(child: BaseSymbol): BaseSymbol | undefined;\n}\n\n/** A symbol with a scope (so it can have child symbols). */\nexport class ScopedSymbol extends BaseSymbol implements IScopedSymbol {\n\n    /** All child symbols in definition order. */\n    #children: BaseSymbol[] = [];\n\n    // All used child names. Used to detect name collisions.\n    #names = new Map<string, number>();\n\n    public constructor(name = \"\") {\n        super(name);\n    }\n\n    /**\n     * @returns A promise resolving to all direct child symbols with a scope (e.g. classes in a module).\n     */\n    public get directScopes(): Promise<ScopedSymbol[]> {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    public get children(): BaseSymbol[] {\n        return this.#children;\n    }\n\n    public get firstChild(): BaseSymbol | undefined {\n        if (this.#children.length > 0) {\n            return this.#children[0];\n        }\n\n        return undefined;\n    }\n\n    public get lastChild(): BaseSymbol | undefined {\n        if (this.#children.length > 0) {\n            return this.#children[this.#children.length - 1];\n        }\n\n        return undefined;\n    }\n\n    public clear(): void {\n        this.#children = [];\n        this.#names.clear();\n    }\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     *\n     * @param symbol The symbol to add as a child.\n     */\n    public addSymbol(symbol: BaseSymbol): void {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        const symbolTable = this.symbolTable;\n        const count = this.#names.get(symbol.name);\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            if (count !== undefined) {\n                throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + (symbol.name ?? \"<anonymous>\") +\n                    \"'\");\n            } else {\n                this.#names.set(symbol.name, 1);\n            }\n\n            const index = this.#children.indexOf(symbol);\n            if (index > -1) {\n                throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + (symbol.name ?? \"<anonymous>\") +\n                    \"'\");\n            }\n        } else {\n            this.#names.set(symbol.name, count === undefined ? 1 : count + 1);\n        }\n\n        this.#children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    public removeSymbol(symbol: BaseSymbol): void {\n        const index = this.#children.indexOf(symbol);\n        if (index > -1) {\n            this.#children.splice(index, 1);\n            symbol.setParent(undefined);\n\n            const count = this.#names.get(symbol.name);\n            if (count !== undefined) {\n                if (count === 1) {\n                    this.#names.delete(symbol.name);\n                } else {\n                    this.#names.set(symbol.name, count - 1);\n                }\n            }\n        }\n    }\n\n    /**\n     * Asynchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to all (nested) children of the given type.\n     */\n    public async getNestedSymbolsOfType<T extends BaseSymbol, Args extends unknown[]>(\n        t: SymbolConstructor<T, Args>): Promise<T[]> {\n        const result: T[] = [];\n\n        const childPromises: Array<Promise<T[]>> = [];\n        this.#children.forEach((child) => {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getNestedSymbolsOfType(t));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * Synchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A list of all (nested) children of the given type.\n     */\n    public getNestedSymbolsOfTypeSync<T extends BaseSymbol, Args extends unknown[]>(\n        t: SymbolConstructor<T, Args>): T[] {\n        const result: T[] = [];\n\n        this.#children.forEach((child) => {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                result.push(...child.getNestedSymbolsOfTypeSync(t));\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A promise resolving to symbols from this and all nested scopes in the order they were defined.\n     */\n    public async getAllNestedSymbols(name?: string): Promise<BaseSymbol[]> {\n        const result: BaseSymbol[] = [];\n\n        const childPromises: Array<Promise<BaseSymbol[]>> = [];\n        this.#children.forEach((child) => {\n            if (!name || child.name === name) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getAllNestedSymbols(name));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A list of all symbols from this and all nested scopes in the order they were defined.\n     */\n    public getAllNestedSymbolsSync(name?: string): BaseSymbol[] {\n        const result: BaseSymbol[] = [];\n\n        this.#children.forEach((child) => {\n            if (!name || child.name === name) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                result.push(...child.getAllNestedSymbolsSync(name));\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to direct children of a given type.\n     */\n    public getSymbolsOfType<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>): Promise<T[]> {\n        return new Promise((resolve) => {\n            const result: T[] = [];\n            this.#children.forEach((child) => {\n                if (child instanceof t) {\n                    result.push(child);\n                }\n            });\n\n            resolve(result);\n        });\n    }\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    public async getAllSymbols<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly = false): Promise<T[]> {\n        const result: T[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (const child of this.#children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (this.isNamespace(child)) {\n                const childSymbols = await child.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent) {\n                const childSymbols = await this.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A list with all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    public getAllSymbolsSync<T extends BaseSymbol, Args extends unknown[]>(t: SymbolConstructor<T, Args>,\n        localOnly = false): T[] {\n        const result: T[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (const child of this.#children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (this.isNamespace(child)) {\n                const childSymbols = child.getAllSymbolsSync(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent) {\n                const childSymbols = this.getAllSymbolsSync(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public override async resolve(name: string, localOnly = false): Promise<BaseSymbol | undefined> {\n        return new Promise((resolve) => {\n            for (const child of this.#children) {\n                if (child.name === name) {\n                    resolve(child);\n\n                    return;\n                }\n            }\n\n            // Nothing found locally. Let the parent continue.\n            if (!localOnly) {\n                if (this.parent) {\n                    resolve(this.parent.resolve(name, false));\n\n                    return;\n                }\n            }\n\n            resolve(undefined);\n        });\n    }\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public override resolveSync(name: string, localOnly = false): BaseSymbol | undefined {\n        for (const child of this.#children) {\n            if (child.name === name) {\n                return child;\n            }\n        }\n\n        // Nothing found locally. Let the parent continue.\n        if (!localOnly) {\n            if (this.parent) {\n                return this.parent.resolveSync(name, false);\n\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     *\n     * @returns the symbol located at the given path through the symbol hierarchy.\n     */\n    public symbolFromPath(path: string, separator = \".\"): BaseSymbol | undefined {\n        const elements = path.split(separator);\n        let index = 0;\n        if (elements[0] === this.name || elements[0].length === 0) {\n            ++index;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let result: BaseSymbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) {\n                return undefined;\n            }\n\n            // eslint-disable-next-line no-loop-func\n            const child = result.children.find((candidate) => { return candidate.name === elements[index]; });\n            if (!child) {\n                return undefined;\n            }\n\n            result = child;\n            ++index;\n        }\n\n        return result;\n    }\n\n    /**\n     * @param child The child to search for.\n     *\n     * @returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    public indexOfChild(child: BaseSymbol): number {\n        return this.#children.findIndex((value: BaseSymbol) => { return value === child; });\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol after the given child symbol, if one exists.\n     */\n    public nextSiblingOf(child: BaseSymbol): BaseSymbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index === -1 || index >= this.#children.length - 1) {\n            return undefined;\n        }\n\n        return this.#children[index + 1];\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol before the given child symbol, if one exists.\n     */\n    public previousSiblingOf(child: BaseSymbol): BaseSymbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index < 1) {\n            return undefined;\n        }\n\n        return this.#children[index - 1];\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public nextOf(child: BaseSymbol): BaseSymbol | undefined {\n        if (!(child.parent)) {\n            return undefined;\n        }\n\n        if (child.parent !== this) {\n            return child.parent.nextOf(child);\n        }\n\n        if (child instanceof ScopedSymbol && child.children.length > 0) {\n            return child.children[0];\n        }\n\n        const sibling = this.nextSiblingOf(child);\n        if (sibling) {\n            return sibling;\n        }\n\n        return (this.parent as ScopedSymbol).nextOf(this);\n    }\n\n    private isNamespace(candidate: unknown): candidate is INamespaceSymbol {\n        return (candidate as INamespaceSymbol).inline !== undefined\n            && (candidate as INamespaceSymbol).attributes !== undefined;\n    }\n}\n"]}